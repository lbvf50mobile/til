# Leetcode: Remove All Adjacent Duplicates In String.

- https://gist.github.com/lbvf50mobile/e8c2d8600bc4094d8e196030232ab690
- https://leetcode.com/submissions/detail/515775735/?from=explore&item_id=3794

First I deleted sequence of similar symbols, just clear repeating symbols from the end.   
That worked for examples:    
```
"abbaca"
"azxxzy"
```

But fails on "aaaaaaaaa".


Ruby code:
```Ruby
# Leetcode: Remove All Adjacent Duplicates In String.
# https://leetcode.com/explore/challenge/card/june-leetcoding-challenge-2021/606/week-4-june-22nd-june-28th/3794/
# Fails on: "aaaaaaaaa".
# @param {String} s
# @return {String}
def remove_duplicates(s)
    stack = []
    # When next element is different or it is an end start clearing.
    (0...s.size).each do |i|
        stack.push(s[i])
        # Start to clear stack.
        if (stack.size >= 2) && (i == s.size - 1 || s[i] != s[i+1])
            # Here I need to remove dublicates from the end.
            j = stack.size-1 # Set pointer to the end of the array.
            # move pointer while prev element is equal to current.
            # when next element is different - stop.
            while stack[j-1] == stack[j] && j > 0
                j -= 1
            end
            # Now pointer stands on the end of duplicates.
            # And need to clear pointer not at the last element.
            stack = stack[0...j] if j != stack.size-1
        end
    end
    stack.join
end
```

Now I just going to use douple pop if last element is equal to previous.

- https://gist.github.com/lbvf50mobile/e8c2d8600bc4094d8e196030232ab690

```Ruby
# Leetcode: Remove All Adjacent Duplicates In String.
# https://leetcode.com/explore/challenge/card/june-leetcoding-challenge-2021/606/week-4-june-22nd-june-28th/3794/
# Accepted.
# Thanks God!
# @param {String} s
# @return {String}
def remove_duplicates(s)
    stack = []
    # When next element is different or it is an end start clearing.
    (0...s.size).each do |i|
        stack.push(s[i])
        # Start to clear stack.
        if (i == s.size - 1 || s[i] != s[i+1])
           while stack.size >= 2 && stack[-1] == stack[-2]
               stack.pop(); stack.pop();
           end
        end
    end
    stack.join
end
```

- https://leetcode.com/submissions/detail/515775735/?from=explore&item_id=3794
 
It's very strange that fastest solutions is a recursive ones with regext and gsub. When character and `\1` just substituted with empty string. Test. One more test.
This is because the tests are changed, now thise simplified code does not works.

```Ruby
# Leetcode: Remove All Adjacent Duplicates In String.
# This code set as a super fast, but does not works on current tests set.
DUPLICATE_CHARACTERS_PATTERN = /(.)\1/.freeze

# @param {String} s
# @return {String}
def remove_duplicates(s)
  candidate = s.gsub(DUPLICATE_CHARACTERS_PATTERN, '')
  s == candidate ? candidate : remove_duplicates(candidate)
end
```

What I got from todays tast is that in Leetcode charts best solutions may be saved for unoptimized code that was run on simple tests.

