# Leetcode: 1089. Duplicate Zeros. Some tests.

- https://leetcode.com/problems/duplicate-zeros/
- https://gist.github.com/lbvf50mobile/403fd21a65010368d70527b6280d493d#file-duplicate_zeros-rb
- https://leetcode.com/problems/duplicate-zeros/discuss/784200/Ruby-straightforward-solution%3A-tmp-array-with-duplicated-zeros-copy-values-from-tmp.

**Straight forward solution:**

During iteration over input array insert in tmp array current element, but if element is zero insert two elements.
In the second iteration over input array indexes set it values by the values from tmp array at the same index.

```Ruby
# Leetcode: 1089. Duplicate Zeros.
# https://leetcode.com/problems/duplicate-zeros/
# Runtime: 52 ms, faster than 65.38% of Ruby online submissions for Duplicate Zeros.
# Memory Usage: 10.4 MB, less than 5.77% of Ruby online submissions for Duplicate Zeros.
# @param {Integer[]} arr
# @return {Void} Do not return anything, modify arr in-place instead.
# Wrong answer.
def duplicate_zeros(arr)
    tmp = arr.each_with_object([]){|x,obj| 
        if x.zero?
            obj.push(0); obj.push(0)
        else
            obj.push(x)
        end
    }
    (0...arr.size).each{|i| arr[i] = tmp[i]}
end
```

21:55
```Ruby
def mutateTheArray(n, a)
    prv = 0
    a.each_with_index do |value, index|
        nxt = index < (a.size - 1) ? a[index+1] : 0
        tmp = value
        a[index] = value + nxt + prv
        prv = tmp
    end
    a
end

```
21:57
```Ruby
def alternatingSort(a)
    tmp = []
    size = a.size
    size.times do |i|
        x = i.even? ? a.shift() : a.pop()
        tmp.push(x)
            
    end
    (1...tmp.size).each do |i|
        return false if tmp[i-1]>=tmp[i]
    end
    true
end
```

```Ruby
def meanGroups(a)
    a.map.with_index{|x,i| [x.sum/x.size.to_f,i]}
    .group_by{|x| x.first}.values.map{|x| x.map(&:last).sort}
    .sort_by{|x| x.first}

end
```

```Ruby
def concatenationsSum(a)
    sm = a.sum
    lg = a.sum{|x| 10*(10**(Math.log10(x).to_i))}
    a.sum{|x| x*lg + sm}
end
```
22:06
