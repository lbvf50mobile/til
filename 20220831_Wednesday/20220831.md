# Leetcode: 417. Pacific Atlantic Water Flow.

**Ruby: From Ocean to the Mountains.**

The solution of this is to use set data structure and move from the water to ground. Saving two sets for both oceans.

How to solve.


Create loops for sides the save cells into the sets for the Pacific and Atlantic oceans.
For each cell call a dfs.
1. Top and Left sides for Pasific Ocean.
2. Right and Bottom side for Atlantic Oceat.

And finally return intercestion of both sets converted to an array.



Previous solution. From Ground to Water. 

Fixed errors:  
1. Icorrect value in the main function. Set INFINITY. Sky is the hightes point.
2. Set vistede in the main fuction. Regect dfs calls. Fixed.
3. Incorrect poistion of defining answer. Fixed.
4. Comma in dfs arrays. Fixed.

Add dp and TLE.
Improved DP still TLE. 

Ruby code(1):
```Ruby
# Leetcode: 417. Pacific Atlantic Water Flow.
# https://leetcode.com/problems/pacific-atlantic-water-flow/
# @param {Integer[][]} heights
# @return {Integer[][]}
# TLE.
def pacific_atlantic(heights)
  @h = heights
  @d = true
  @dp = Array.new(@h.size).map{ Array.new(@h[0].size,false)}
  # 1 - Pacific.
  # 2 - Atlantic.
  # 0 - Nothing.
  # 3 = (1|2) Both.
  answer = []
  (0...@h.size).each do |i|
    (0...@h[0].size).each do |j|
      if @dp[i][j]
        tmp = @dp[i][j]
      else
        @v = get_visited
        tmp = dfs(i,j, Float::INFINITY) # Water come frome the sky. 
        @dp[i][j] = tmp
      end
      answer.push([i,j]) if 3 == tmp 
    end
  end
  return answer
end

def get_visited
  Array.new(@h.size).map{ Array.new(@h[0].size,false)}
end

def dfs(i,j,value)
  return 1 if 0 > i
  return 1 if 0 > j
  return 2 if i == @h.size
  return 2 if j == @h[0].size
  return 0 if @h[i][j] > value
  return 0 if @v[i][j]
  return @dp[i][j] if @dp[i][j]
  val = @h[i][j]
  answer = 0
  @v[i][j] = true
  [[i+1,j],[i-1,j],[i,j+1],[i,j-1]].each do |ii,jj|
    answer |= dfs(ii,jj,val)
  end
  return answer
end


```
