# Leetcode: 1405. Longest Happy String.

- https://gist.github.com/lbvf50mobile/4084f656a846efaf52986c9dbb971dcc

The idea, sub problem is character to start, and number of characters. If there is a negative amount of any characters an empty string wold be return. 

Great, next line of deduction, for current symbol if it is equal to zero, it would return zero too. If require "zero" return "zero". Now two cases are covered, negative amount, and zero amount when in all this cases return empty string. Great. Nothing to add.

Next, current symbol could be matched ones o twice in a row. Let check first if it matched ones. In this case set current character and add recursive call for next ones with a decreased. If current is 'a', and there is one or more 'a' need to call for 'a' with b, and 'a' with 'c', of course with reduced 'a'.

In general, we check that we could take some elements from the account, if there is negative account, it is impossible, every section of the account must be zero at least. And if we want to make account negative this is impossible too.

For this consumption I have current code:
```Ruby
# Leetcode: 1405. Longest Happy String.
# https://leetcode.com/problems/longest-happy-string/
# @param {Integer} a
# @param {Integer} b
# @param {Integer} c
# @return {String}
# need to test TLE: 25, 88, 98
# Works: 0,8,11
# Works: 1,1,7
def longest_diverse_string(a, b, c)
    [rec(?a,a,b,c),rec(?c,a,b,c),rec(?b,a,b,c)].max_by{|x| x.size}
end

def rec(q,a,b,c)
    return "" if a < 0 || b < 0 || c < 0 # Negaive seciton in account, took more then possible. Impossible.
    return "" if (?a == q && 0 == a) || (?b == q && 0 == b) || (?c == q && 0 == c) # Trying to take more then possible.
    answer = ""
    if ?a == q && a >= 1
        tmp = ?a + rec(?b,a-1,b,c)
        answer = tmp if tmp.size > answer.size
        tmp = ?a + rec(?c, a-1,b,c)
        answer = tmp if tmp.size > answer.size
    end
    if ?b == q && b >= 1
        tmp = ?b + rec(?a,a,b-1,c)
        answer = tmp if tmp.size > answer.size
        tmp = ?b + rec(?c, a,b-1,c)
        answer = tmp if tmp.size > answer.size
    end
    if ?c == q && c >= 1
        tmp = ?c + rec(?a,a,b,c-2)
        answer = tmp if tmp.size > answer.size
        tmp = ?c + rec(?b, a,b,c-2)
        answer = tmp if tmp.size > answer.size
    end
    # and now two or more
    if ?a == q && a >= 2
        tmp = 'aa' + rec(?b,a-2,b,c)
        answer = tmp if tmp.size > answer.size
        tmp = 'aa' + rec(?c, a-2,b,c)
        answer = tmp if tmp.size > answer.size
    end
    if ?b == q && b >= 2
        tmp = 'bb' + rec(?a,a,b-2,c)
        answer = tmp if tmp.size > answer.size
        tmp = 'bb' + rec(?c, a,b-2,c)
        answer = tmp if tmp.size > answer.size
    end
    if ?c == q && c >= 2
        tmp = 'cc' + rec(?a,a,b,c-2)
        answer = tmp if tmp.size > answer.size
        tmp = 'cc' + rec(?b, a,b,c-2)
        answer = tmp if tmp.size > answer.size
    end
    answer
end

```