# Leetcode: 1887. Reduction Operations to Make the Array Elements Equal.

- https://gist.github.com/lbvf50mobile/f401cc6d3bf1d188d4110d36a393eebe

**Ruby/Go: Sort keys descending and accumulate sum updating prev_max_amount.**

Here are two keys:
1. Current max value amount always extended by previous max value.
2. It is important to move from bigest index of a Counter to smallest because:

```
[5:1; 2:50, 1:100]
```
Prev_max | Total_max | Answer 
--- | --- | ---
0 | (0+1) = 1 | (0+1) = 1 
1 | (1+50) = 51 | (1+51) = 52

Ans: 52

```
[2:50, 5:1, 1:100]
```
Prev_max | Total_max | Answer
--- | --- | ---
0 | (0+50) = 50 | (0+50) = 50
50 | (50+1) = 51 | (50+51) = 101

Ans: 101 Incorrect!

Priority is important. Because it is not a simple prefix sum. Here is a
"douple adding". If for Total_max there is no need for priority, for answer it
is important.



Ruby code:
```Ruby
# Leetcode: 1887. Reduction Operations to Make the Array Elements Equal.
# https://leetcode.com/problems/reduction-operations-to-make-the-array-elements-equal
# = = = = = = = = = = = = = =
# Accepted.
# Thanks God, Jesus Christ!
# = = = = = = = = = = = = = =
# Runtime: 339 ms, faster than 100.00% of Ruby online submissions for
# Reduction Operations to Make the Array Elements Equal.
# Memory Usage: 229.2 MB, less than 100.00% of Ruby online submissions for
# Reduction Operations to Make the Array Elements Equal.
# 2023.11.19 Daily Challenge.
# @param {Integer[]} nums
# @return {Integer}
def reduction_operations(nums)
  ans = 0
  prev_max_amount = 0
  # 1. Create a Counter.
  counter = nums.tally
  # 2. Find Minimum in key.
  min = counter.keys.min
  # 3. Sort descending and Sum all non-minimum key's values.
  # Sum in a tricky way. Every time add an ans one more time. Because on every
  # step amount of next largest equals to it's value plus previous decireased
  # values.
  counter.to_a.sort_by(&:first).reverse.each do |i,v|
    if i != min
      prev_max_amount += v
      ans += prev_max_amount 
    end
  end
  return ans
end
```
