# Leetcode: 662. Maximum Width of Binary Tree.

**Ruby: Number x in a level: left 2x-1, right 2x.**

Take a look, if split a binary tree into levels, element (node) `#1` always born `#1`
and `#2`. And element (node) `#2` always born `#3` and `#4`.

```
       1
   1       2
 1   2   3   4
1 2 3 4 5 6 7 8
```
This gives a rule: for `x` left child number is `2x-1` and right child is `2x`.

Let's compare.

- 1  `2*1-1=1` `2*1=2`;
- 2  `2*2-1=3` `2*2=4`;
- 3  `2*3-1=5` `2*3=6`;
- 4  `2*4-1=7` `2*4=8`;

Correct.

Neet to store number in a level for current node and in a BFS loop calculate a new
one numbers in the next level.

To find width need from last element of a level array delete first element of
level array and add one.


Ruby code:
```Ruby
# Leetcode: 662. Maximum Width of Binary Tree.
# https://leetcode.com/problems/maximum-width-of-binary-tree/
# = = = = = = = = = = = = = =
# Accepted.
# Thanks God, Jesus Christ!
# = = = = = = = = = = = = = =
# Runtime: 93 ms, faster than 83.33% of Ruby online submissions for Maximum
# Width of Binary Tree.
# Memory Usage: 211.6 MB, less than 100.00% of Ruby online submissions for
# Maximum Width of Binary Tree.
# 2023.04.20 Daily Challenge.

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
def width_of_binary_tree(root)
  q = [[root,1]] # [el, number_in_a_level];
  max = 0
  while !q.empty?
    width = q.last.last - q.first.last + 1
    max = width if width > max
    nq = []
    q.each do |el,x| # x - number in a level.
      nq.push([el.left,2*x-1]) if el.left
      nq.push([el.right,2*x]) if el.right
    end
    q = nq
  end
  return max
end
```
