# Leetcode: 658. Find K Closest Elements.

- https://leetcode.com/explore/challenge/card/july-leetcoding-challenge-2021/608/week-1-july-1st-july-7th/3800/
- https://gist.github.com/lbvf50mobile/7011a8f70cce1d21993a651e2e5d8ac3 
- https://leetcode.com/problems/find-k-closest-elements/

Idea is to create sliding window with k elements that is defined by sum of differences and last index of windows. Find minimum. And at the of the loop slice the window from array.

Ruby code:
```Ruby
# Leetcode: Find K Closest Elements.
# https://leetcode.com/explore/challenge/card/july-leetcoding-challenge-2021/608/week-1-july-1st-july-7th/3800/
# Accepted.
# Thanks God!
# @param {Integer[]} arr
# @param {Integer} k
# @param {Integer} x
# @return {Integer[]}
def find_closest_elements(arr, k, x)
  a = arr.map{|el| (el-x).abs}
    # p a
    # p arr
    sum = 0
    (0...k).each do |i|
        sum += a[i]
    end
    min = sum
    j = k-1
    
    (k...a.size).each do |i|
        sum -= a[i-k]
        sum += a[i]
        if sum < min
            min = sum
            j = i
        end
        # p [i,sum]
    end
    # p a
    # p arr
    arr[j-k+1..j]
end
```
Ok. It's time to solve.

# Leetcode: Max Sum of Reactangle no large then K.

- https://leetcode.com/explore/challenge/card/july-leetcoding-challenge-2021/608/week-1-july-1st-july-7th/3801/

I will start from solution on one line matrix.

- https://youtu.be/N0_816yrFrY
- https://www.geeksforgeeks.org/subarray-whose-sum-is-closest-to-k/


Idea is: Save prefix somes for `i` in a sorted array with uniq values. To make uniq set would have and on each step the prefix array will be sorted.
Next there is `PS` current and `SPS` search prefix sum.  `SPS` stays before. So idealy `PS - SPS = K`.

```
PS - SPS <= K
PS - K - SPS <= 0
PS - K <= SPS
```

Now I have a question must it be left or right, lets consiter left. Because I'm seeking (PS-K) this is what I really get. **But Wait!**
X it is SPS, PS-K <= X.

- https://www.rubydoc.info/stdlib/core/Array:bsearch

When I have a SPS, I can create SUM and check it. It must be les then K but Maximum.

- https://gist.github.com/lbvf50mobile/68320d9718dd355eeaa373de5380a20e

This code implements idea of stripes. Functions that solves problem for plane array, and this function gets all possible horisontal stripes from the matrix.

Ruby code:
```Ruby
# Leetcode: Max Sum of Rectangle No Larger Than K.
# https://leetcode.com/explore/challenge/card/july-leetcoding-challenge-2021/608/week-1-july-1st-july-7th/3801/
# Fails: 
# [[2,2,-1]]
# 0
# @param {Integer[][]} matrix
# @param {Integer} k
# @return {Integer}
def max_sum_submatrix(matrix, k)
    require 'set'
    @k = k
    
    # Extend Matrix by one row for a prefix sum in columns.
    mx = Array.new(matrix.size + 1).map{Array.new(matrix[0].size,0)}
    
    # Fill prefix sum for every row
    (0...matrix[0].size).each do |j|
        (0...matrix.size).each do |i|
            mx[i+1][j] = mx[i][j] + matrix[i][j] # mx start from one.
        end
    end
    
    max = nil
    # Now use stripes concept.
    (0...mx.size-1).each do |bottom|
        (bottom+1...mx.size).each do |top|
            # Now create line.
            stripe = Array.new(mx[0].size)
            stripe[0] = mx[top][0] - mx[bottom][0]
            (1...mx[0].size).each do |j|
                stripe[j] = stripe[j-1] + (mx[top][j] - mx[bottom][j])
            end
            tmp = line(stripe)
            if tmp
                max = tmp if max.nil?
                max = tmp if tmp > max
            end
        end
    end
    max
end

def line(arr)
    max = nil
    
    ps = arr[0] # Prefix sum.
    sps_arr = [ps] # Implement binary search by sps_arr.
    sps_set = Set[ps] # Implement control of uniq values.
    
    # Need to add 0 to sps_arr to be able work with subarrays 
    # started from begining.
    if !sps_set.include?(0)
        sps_set.add(0)
        sps_arr.push(0)
        sps_arr.sort!
    end
    
    # First time set sum.
    sum = ps
    # puts "Fists sum: #{sum}."
    if sum <= @k
        max = sum
        # puts "Set firxt max = #{max}"
    end
    
    (1...arr.size).each do |i|
        ps += arr[i]
        # puts "i = #{i}, ps = #{ps}, #{sps_arr}"
        sps = sps_arr.bsearch{|x| x >= ps - @k} # or K >= ps - x only possible way.
        
        if sps
            sum = ps - sps
            max = sum if max.nil?
            max = sum if sum > max
        end
        
        # Add new element to sps_arr and sps_set.
        if !sps_set.include?(ps)
            sps_set.add(ps)
            sps_arr.push(ps)
            sps_arr.sort!
        end
    end
    
    max
end
```

