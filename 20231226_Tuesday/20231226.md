# Leetcode: 1155. Number of Dice Rolls With Target Sum.

- https://gist.github.com/lbvf50mobile/3613bd378d337177540c40881329c540
- https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/discuss/4462176/Go%3A-First-loop-dices-second-position-third-delta.

**Go: First loop dices, second position, third delta.**


This is a Push DP, with two imaginary entities zero dice and zero position.
The general idea is to throw dice from a sum of previous dice and add value of
ways to reach previous dice to a column of the current one row.

Simplified: Problem address is dice number and total sum, poblmes value
numbers of ways to reach that sum.

Solution: Fill values for a current dice from a previous dice. Curren value
generated by adding values from a previous dices.



So. Solved by a matrix.


- Rows are dices.
- Columns are total score from zero till target (inclusive).


Create a matrix and fill 0 matrix and 0 value by 1. Only one way to get a
state when no dice are thrown and the score is zero.


- Further. In the first loop iterate over all dices.
- In the second loop iterates from `0` till `target-1`.
- In the third loop `throw` dice `k` times from a position of a previous loop
  and fill current row.


Main formula.

`dp[i][j+delta] += dp[i-1][j] // Delata is a dice's face value.`

Go code:
```Go
// Leetcode: 1155. Number of Dice Rolls With Target Sum.
// https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/
// = = = = = = = = = = = = = =
// Accepted.
// Thanks God, Jesus Christ!
// = = = = = = = = = = = = = =
// Runtime: 12 ms, faster than 53.85% of Go online submissions for Number of
// Dice Rolls With Target Sum.
// Memory Usage: 5.5 MB, less than 19.23% of Go online submissions for Number
// of Dice Rolls With Target Sum.
// 2023.12.26 Daily Challenge.

package main

func numRollsToTarget(n int, k int, target int) int {
	mod := 1000000007
	dp := make([][]int, n+1) // One row - one dice, + imagenery one.
	for i := 0; i < n+1; i += 1 {
		dp[i] = make([]int, target+1) // Number of sum to reach.
	}
	dp[0][0] = 1 // Only one way to get to the zero.
	// Throw each dice.
	for i := 1; i < n+1; i += 1 {
		// Throw position.
		for j := 0; j < target; j += 1 {
			// dice value.
			for v := 1; v <= k; v += 1 {
				if j+v <= target {
					dp[i][j+v] = (dp[i][j+v] + dp[i-1][j]) % mod
				}
			}
		}
	}
	return dp[n][target]
}
```
