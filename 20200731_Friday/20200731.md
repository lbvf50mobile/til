# Leetcode: 1029. Two City Scheduling. (code, article); Leetcode: 1025. Divisor Game.

## Leetcode: 1029. Two City Scheduling.

- https://leetcode.com/problems/two-city-scheduling/
- https://gist.github.com/lbvf50mobile/4287b62e14f5918ce80b9cc0d271d316

Description of this task is really unclear, and need to spend some time to calculate what do this mysterious N and 2N means.

Ok. There is an Array of size. And in the company amount there is size amount of people. Half of them must be in city A, and half of them must be in city B. N it is a half of the size of the array.

This task could be solved by dynamic programming approach. Each person could go to A city if there less then half of persons already there, or cold go to B city if less then half of company members already there.  This means for each person and number of team members in each city there is on minimum sum next persons could spend for travel depend on their selection. And this is sum is minimum for select travel to city A and optimal solutions of next people, and travel to city B and optimal solutions of next members.

Thus after comparing this two ways and select minimal one, it is possible to cache this sum for person under index `i` with `X places available to city A` and `Y places available to city B` - this is a core of top-down dynamic programming approach.  Test all possible ways select appropriate and cache it for other calls.

Ruby code:
```Ruby
# Leetcode: 1029. Two City Scheduling.
# https://leetcode.com/problems/two-city-scheduling/
# Runtime: 224 ms, faster than 9.30% of Ruby online submissions for Two City Scheduling.
# Memory Usage: 10.2 MB, less than 100.00% of Ruby online submissions for Two City Scheduling.
# @param {Integer[][]} costs
# @return {Integer}
def two_city_sched_cost(costs)
    @dp = {}
    @costs = costs
    top_down(0,costs.size/2, costs.size/2)
end

def top_down(i, a, b)
    return 0 if 0 == a && 0 == b
    arr = [i, a, b]
    return @dp[arr] if @dp[arr]
    if 0 == a
        x = @costs[i][1] + top_down(i+1,a,b-1)
        return @dp[arr] = x;
    end
    if 0 == b
        x =  @costs[i][0] + top_down(i+1,a-1,b)
        return @dp[arr] = x;
    end
    x = [@costs[i][1] + top_down(i+1,a,b-1),@costs[i][0] + top_down(i+1,a-1,b)].min
    @dp[arr] = x;
end
```

```Ruby
# Leetcode: 1025. Divisor Game.
# https://leetcode.com/problems/divisor-game/
# @param {Integer} n
# @return {Boolean}
def divisor_game(n)
    
end
```