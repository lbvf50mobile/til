- I have a set with all positive numbers. It is impossible to store. To large.
- Remove minimal number. And and the begning it is 1. These nums easy to store.
- Put number back. It is easy to do by comparing with set.

All questions are stored around POP. If have a sequence of POP, POP, POP it easy
to solve by a pointer that moves right. But allso here appears a Returned
nubers.

So what to do?

- When pop select minimum from returned it is min heap, or sorted array.
- And from Next to Remove. Next_To_Remove it is a pointer from POP, POP, POP.

Ok. Now edge cases.

Next_To_Remove always will be the biggest. But it can move back in case of Adds.
If Adds == Next_To_Remove - 1.

Summary:
- Create pointer `i` it goint to be next_to_remove.
- Create Hash deleted, where delete are stroed.
- Create a MinHeap (in Ruby Case it would be sorted array). 

Method POP.

- if Heap empty `i += 1`, Set `i-1` in Hash, return `i-1`;
- if heap not empty.
- - If heap.top < i; x = heap.pop, Hash[x] = false; return x;
- - else `i+=1`, Set `i-1` in Hash, return `i-1`;

Method Add;

- Do nothing if is not in Hash.
- If in Hash, set Hash[x] = false, if x == i - 1 then i -= 1;

Look likes it done. Let's try.

Ruby code:
```Ruby
```
