# Leetcode: 941. Valid Mountain Array.

- https://gist.github.com/lbvf50mobile/0ee2a183ead8c9422e59fd0b79f2555b
 
**Ruby: State machine, array for transitions check.**

Each element of the input array has a state.

- 0 increasing element.
- 1 peack element.
- 2 decreasing element.

Conditions. For `i` to has a state.

- `0`  `a[i] > a[i-1]`.
- `1` `a[i-1] < a[i] && a[i] > a[i+1]`
- `2` `a[i] > a[i+1]`


Rules for transitions.
- current `0`  previous `0`.
- current `1` previous `0`.
- current `2` previous `1`.

If rules is not respected return false.
At the end of the loop current state must be `2`.
Also need to store previous state.

Solution is check arrays size, check state of a second element, start loop from the third element and check transition rule on every iteration. At the end check current state.

Let's try.

Ruby code:
```Ruby
# Leetcode: 941. Valid Mountain Array.
# https://leetcode.com/problems/valid-mountain-array/
# @param {Integer[]} arr
# @return {Boolean}
def valid_mountain_array(arr)
  @a = arr
  @size = arr.size
  return false if @size < 3
  state_prev = 0
  state_cur = get_state(1)
  return false if ! state_cur
  return false if 2 == state_cur 
  rules = [ # Previous state for current one. Current one is an index.
    ->x{ 0 == x},
    ->x{ 0 == x},
    ->x{ 1 == x && 2 == x} 
  ]   
  (2...@size).each do |i|
    tmp = state_prev
    state_prev = state_cur
    state_cur = get_state(i)
    return false if ! state_cur
    return false if rules[state_cur][tmp]
  end
  2 == state_cur
end

def get_state(i)
  return 0 if 0 == i
  return 0 if i != @size-1 && @a[i-1] < @a[i] && @a[i] < @a[i+1]
  return 1 if i != @size-1 && @a[i-1] < @a[i] && @a[i] > @a[i+1]
  return 2 if @a[i-1] > @a[i]
  return false
end
```
