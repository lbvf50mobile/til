# Leetcode: 454. 4Sum II.

- https://gist.github.com/lbvf50mobile/fa045de0d72ff36f965f00338ccfbf1a

**Ruby: All possible sums of first part and second part.**

Find all possible sums from `nums1` and `nums2` is would be `200*200 = 40_000` elements. The same for `nums3` and `nums4` again `40_000` elements. 

At this point need to use Algebra `a + b = 0; b = -a; a = -b;`.
If `a_array` is all possible sums of `nums1` and `nums2` elements. Then `b_array` is all possible sums of `nums3` and `nums4`.  And if create `a_hash` that as a keys stores values from `a_array` and as a value `number of matches` it would be possible to find how many `b = -a` simple getting `a_hash[-b]`.

And solutiong requires `O(N*N)` time and `O(N*N)` memory.

Let's try.

Note: Instead `+` used `*` this leads to error and thoguht about incorrect Algorithm: `And this does not work`.
Note: Really does not work.

Ruby code:
```Ruby
# Leetcode: 454. 4Sum II.
# https://leetcode.com/problems/4sum-ii/
# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @param {Integer[]} nums3
# @param {Integer[]} nums4
# @return {Integer}
def four_sum_count(nums1, nums2, nums3, nums4)
  a_array = possible_sum_values(nums1, nums2)
  b_array = possible_sum_values(nums3, nums4)
  a_hash = get_hash_counter(a_array)
  answer = 0
  b_array.each do |b|
    answer += 1 if a_hash[-b]
  end
  answer
end

def possible_sum_values(a,b)
  ans = []
  a.each do |x|
    b.each do |y|
      ans.push(x*y)
    end
  end
  ans
end

def get_hash_counter(x)
  x.each_with_object(Hash.new){|el,o| o[el] ||= 0; o[el] += 1;}
end
```
