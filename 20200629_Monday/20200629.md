# Leetcode: 914. X of a Kind in a Deck of Cards. Some tests.

## Leetcode: 914. X of a Kind in a Deck of Cards.

- https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/
-  https://gist.github.com/lbvf50mobile/9d8fbc6c76d6cbe8604a3560704211f3
- https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/discuss/711897/Ruby-solution-with-description-O(N2)-just-to-make-it-works.

Need to create histogram for input array. And check are there such number in interval `[2,input_array_size]`, that divide all elements of histogram without divider.

Ruby code:
```Ruby
# Leetcode: 914. X of a Kind in a Deck of Cards.
# https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/
# Runtime: 104 ms, faster than 9.52% of Ruby online submissions for X of a Kind in a Deck of Cards.
# Memory Usage: 10.5 MB, less than 50.00% of Ruby online submissions for X of a Kind in a Deck of Cards.
# @param {Integer[]} deck
# @return {Boolean}
def has_groups_size_x(deck)
    x = deck.group_by{|x| x}.values.map{|x| x.size}
    min = x.min
    return false if 1 == x.min
    return true if 1 == x.size
    (2..deck.size).each do |i|
        return true if x.all?{|y| 0 == y%i}
    end
    false
end
```

## Some tests.

Given an integer n and an array a of length n, your task is to apply the following mutation to a:

Array a mutates into a new array b of length n.
For each i from 0 to n - 1, b[i] = a[i - 1] + a[i] + a[i + 1].
If some element in the sum a[i - 1] + a[i] + a[i + 1] does not exist, it should be set to 0. For example, b[0] should be equal to 0 + a[0] + a[1].
Example

For n = 5 and a = [4, 0, 1, -2, 3], the output should be mutateTheArray(n, a) = [4, 5, -1, 2, 1].

b[0] = 0 + a[0] + a[1] = 0 + 4 + 0 = 4
b[1] = a[0] + a[1] + a[2] = 4 + 0 + 1 = 5
b[2] = a[1] + a[2] + a[3] = 0 + 1 + (-2) = -1
b[3] = a[2] + a[3] + a[4] = 1 + (-2) + 3 = 2
b[4] = a[3] + a[4] + 0 = (-2) + 3 + 0 = 1
So, the resulting array after the mutation will be [4, 5, -1, 2, 1].

Ruby code:
```Ruby
def mutateTheArray(n, a)
    prv= 0
    (0...a.size).each do |i|
        tmp = a[i]
        nxt = i <= (a.size - 2) ? a[i+1] : 0
        a[i] = a[i] + nxt + prv
        prv = tmp
    end
    a
end

```

You are given an array of integers a. A new array b is generated by rearranging the elements of a in the following way:

b[0] is equal to a[0];
b[1] is equal to the last element of a;
b[2] is equal to a[1];
b[3] is equal to the second-last element of a;
and so on.
Your task is to determine whether the new array b is sorted in strictly ascending order or not.

Example

For a = [1, 3, 5, 6, 4, 2], the output should be alternatingSort(a) = true.

The new array b will look like [1, 2, 3, 4, 5, 6], which is in strictly ascending order, so the answer is true.

For a = [1, 4, 5, 6, 3], the output should be alternatingSort(a) = false.

The new array b will look like [1, 3, 4, 6, 5], which is not in strictly ascending order, so the answer is false.

```Ruby
def alternatingSort(a)
    asc = ->x{
        (1...x.size).each do |i|
            return false if x[i-1] >= x[i]
        end
        true
    }
    b = []
    x,y = 0,a.size-1
    (0...a.size).each do |i|
        if i.even?
            b.push(a[x])
            x += 1
        else
            b.push(a[y])
            y -= 1
        end
    end
    
    asc[b]
end

```
You are implementing your own programming language and you've decided to add support for merging strings. A typical merge function would take two strings s1 and s2, and return the lexicographically smallest result that can be obtained by placing the symbols of s2 between the symbols of s1 in such a way that maintains the relative order of the characters in each string.

For example, if s1 = "super" and s2 = "tower", the result should be merge(s1, s2) = "stouperwer".



You'd like to make your language more unique, so for your merge function, instead of comparing the characters in the usual lexicographical order, you'll compare them based on how many times they occur in their respective strings (fewer occurrences means the character is considered smaller). If the number of occurrences are equal, then the characters should be compared in the usual way. If both number of occurences and characters are equal, you should take the characters from the first string to the result.

Given two strings s1 and s2, return the result of the special merge function you are implementing.

Example

For s1 = "dce" and s2 = "cccbd", the output should be
mergeStrings(s1, s2) = "dcecccbd".
All symbols from s1 goes first, because all of them have only 1 occurrence in s1 and c has 3 occurrences in s2.



For s1 = "super" and s2 = "tower", the output should be
mergeStrings(s1, s2) = "stouperwer".
Because in both strings all symbols occur only 1 time, strings are merged as usual. You can find explanation for this example on the image in the description.

```Ruby
def mergeStrings(s1, s2)
    histogram = ->x{ 
        x.chars.each_with_object(Hash.new){|v,obj| obj[v] ||= 0; obj[v] += 1}
        }
    h1,h2 = histogram[s1],histogram[s2]
    s1,s2 = s1.chars, s2.chars
    ans = []
    while (!s1.empty?) && (!s2.empty?)
        a,b = s1.first, s2.first
        if h1[a] == h2[b]
            if a == b
                ans.push(s1.shift)
            elsif a < b
                ans.push(s1.shift)
            else
                ans.push(s2.shift)
            end
        elsif h1[a] < h2[b]
            ans.push(s1.shift)
        else
            ans.push(s2.shift)
        end
    end
    ans += s1 if !s1.empty?
    ans += s2 if !s2.empty?
    ans.join
end
```


Given an array of positive integers a, your task is to calculate the sum of every possible a[i] ∘ a[j], where a[i] ∘ a[j] is the concatenation of the string representations of a[i] and a[j] respectively.

Example

For a = [10, 2], the output should be concatenationsSum(a) = 1344.

a[0] ∘ a[0] = 10 ∘ 10 = 1010,
a[0] ∘ a[1] = 10 ∘ 2 = 102,
a[1] ∘ a[0] = 2 ∘ 10 = 210,
a[1] ∘ a[1] = 2 ∘ 2 = 22.
So the sum is equal to 1010 + 102 + 210 + 22 = 1344.

For a = [8], the output should be concatenationsSum(a) = 88.

There is only one number in a, and a[0] ∘ a[0] = 8 ∘ 8 = 88, so the answer is 88.

```Ruby
def concatenationsSum(a)
    sm = a.sum
    lg = a.sum{|x| 10**Math.log10(x*10).to_i  }
    a.sum{|x| x*lg + sm}
end

```