# Leetcode: 794. Valid Tic-Tac-Toe State.

- https://leetcode.com/problems/valid-tic-tac-toe-state/


Ruby code, wining positions bit masks:
```Ruby
p "alias x='ruby 20210330_Tuesday/20210330.rb'" 
p "https://gist.github.com/lbvf50mobile/f13743dde4696cbf09124925d05bbb6c"
p "https://leetcode.com/problems/valid-tic-tac-toe-state/"

bottom_row = 1 | (1 << 1) | (1 << 2)
midle_row = bottom_row << 3
top_row = midle_row << 3

p [bottom_row.to_s(2), midle_row.to_s(2), top_row.to_s(2)]

left_col =  (1<<8) | (1 << 5) | (1 << 2)
midle_col = left_col >> 1
right_col = midle_col >> 1
p [left_col.to_s(2), midle_col.to_s(2),right_col.to_s(2)]

left_dig = (1 << 8) | (1 << 4) | 1
right_dig = (1 << 2) | (1 << 4) | (1 << 6)
p [left_dig.to_s(2), right_dig.to_s(2)]

p [bottom_row, midle_row, top_row, left_col, midle_col, right_col, left_dig, right_dig]
```

After win game must be finished, this means, if X wins, there are must be no unmarked O. Even more: after win there must be no unmarked x and o.  

Mark, check for win, if win check for no unmarked places, if not win call recursion. - This is the algorithm. Algorithm is a Back tracking find a valid way to play a game.
To check game finished, need to prepare all marked X and O as a bits, and it going to be called marks mask.   

If no moves and all marked that's true.        

Ruby code:
```Ruby
# Leetcode: 794. Valid Tic-Tac-Toe State.
# https://leetcode.com/problems/valid-tic-tac-toe-state/
# @param {String[]} board
# @return {Boolean}

def valid_tic_tac_toe(board)
    @b = board.map(&:chars).flatten
    @marks_mask = create_marks_mask()
    x_marks, y_marks, all_marks = 0,0,0
    x_turn = true
    return check(x_turn,x_marks, y_marks, all_marks)
end

def check(x_turn, x_marks, y_marks, all_marks)
    char = x_turn ? ?X : ?O
    nt = ! x_turn # next turn;
    cur_mark = x_turn ? x_marks : y_marks
    nxt_mrk, nxt_glbl = 0, 0
    answer = false
    no_moves = true
    (0...9).reverse_each_do |i|
        bit = 1 << (8 - i)
        if @b[i] == char
            no_moves = false
            nm = cur_mark | bit # next mark;
            ng = all_marks | bit # next global;
            return true if check_win(nm) && check_no_unmarked(ng)
            answer = x_turn ? check(nt,nm,y_marks,ng) : check(nt,x_marks,nm,ng)
            return true if answer
        end
    end
    
    return true if no_moves && check_nu_unmakred(all_marks)
    return false
end

def check_win(marks)
    [7, 56, 448, 292, 146, 73, 273, 84].any?{|x| 0 == ((marks & x) ^ x)}
end

def create_marks_mask()
    mask = 0
    (0...9).reverse_each do |i|
        if ?X == @b[i] || ?O == @b[i]
            mask = mask | (1 << (8-i))
        end
    end
    mask
end
def check_no_unmarked(mask)
    0 == (mask ^ @marks_mask)
end

```