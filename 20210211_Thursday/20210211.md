# Leetcode: 1405. Longest Happy String.

Yesterday I solved 1405 as a DP where sub problem defined as character to start and amount of characters to select elements from. And when making decision what character would be a next one, selected cachar with maximum amount.

So now I going to try write clear greedy solution, I wrote one where next element is most common, but this does not work. Let write this code one more time.

```Ruby
# Leetcode: 1405. Longest Happy String.
# https://leetcode.com/problems/longest-happy-string/
# Runtime: 404 ms, faster than 50.00% of Ruby online submissions for Longest Happy String.
# Memory Usage: 269.1 MB, less than 50.00% of Ruby online submissions for Longest Happy String.
# @param {Integer} a
# @param {Integer} b
# @param {Integer} c
# @return {String}
# Fails: 0,8,11 
def longest_diverse_string(a, b, c)
    @x = [[?a,a],[?b,b],[?c,c]].sort_by{|x| -x[1]}
    ans = ""
    prev_char = ""
    while true
        tmp = get_max_not(prev_char)
        break if tmp.empty?
        ans += tmp
        prev_char = tmp[0]
    end
    ans
end

def get_max_not(prev_char)
    @x.sort_by{|x| -x[1]}
    p @x.sort_by{|x| x[0]}.map(&:last)
    3.times do |i|
        if prev_char != @x[i][0]
            if @x[i][1] >= 2
                @x[i][1] -= 2
                return  @x[i][0] * 2
            end
            if @x[i][1] >= 1
                @x[i][1] -= 1
                return @x[i][0]
            end
        end
    end
    return ""
end
```

Yes and this fails.

Next Idea is to create three elements packs.
Create 3 elements that starts not from some digit.
And for this tool I need to ask give 2 or give 1.

It action.
```Ruby
# Leetcode: 1405. Longest Happy String.
# https://leetcode.com/problems/longest-happy-string/
# Runtime: 404 ms, faster than 50.00% of Ruby online submissions for Longest Happy String.
# Memory Usage: 269.1 MB, less than 50.00% of Ruby online submissions for Longest Happy String.
# @param {Integer} a
# @param {Integer} b
# @param {Integer} c
# @return {String}
# Fails: 0,8,11 
def longest_diverse_string(a, b, c)
    @x = [[?a,a],[?b,b],[?c,c]].sort_by{|x| -x[1]}
    ans = ""
    prev_char = ""
    while true
        tmp = get_three(prev_char)
        p tmp
        break if tmp.empty?
        ans += tmp
        prev_char = tmp[0]
    end
    ans
end

def get_three(prev_char)
    ans = ""
    while ans.size < 3
        tmp = ans.size < 2 ? get_max_not(prev_char) : get_max_not(prev_char,false) 
        break if tmp.empty?
        prev_char = tmp[0]
        ans += tmp
    end
    ans
end

def get_max_not(prev_char, give_two = true)
    p [prev_char,give_two]
    @x.sort_by{|x| -x[1]}
    3.times do |i|
        if prev_char != @x[i][0]
            if @x[i][1] >= 2 && give_two
                @x[i][1] -= 2
                return  p @x[i][0] * 2
            end
            if @x[i][1] >= 1
                @x[i][1] -= 1
                return p @x[i][0]
            end
        end
    end
    return ""
end

```


