# Leetcode: 56. Merge Intervals. 

- https://gist.github.com/lbvf50mobile/2f6a9bddad853019030fd8561b1b68d9

If there are two intervals `[s1,e1]` and `[s2,e2]`. They are ovelaped if `s1 <= e2 && e1 >= s2`.


- `s1 <= e1` this means first interval is not too right. Start after second ends.
```
S1 <= E2
                 (S1)=====================(E1)
   (S2)--------------(E2)
```
- `e1 >= s2` this means first interval is not to left. Ends before seconts starts.
```
E1 >= S2
 (S1)=====================(E1)
                     (S2)--------------(E2)
```

It is a rule to merge two intervals `s1 <= e2 && e1 >= s2`.   
Now need to sort intervals by there starts and ends. Because there are no infromation that intervals are sorted.

And generate a new answer array.   

Push first element of sorted array into the answer. Continue operating with two pointers, first pointer always at the end of the answer array, second at the current element of the sorted array. 

If two elements are overlaped merge them, if not push new element into the answer array, move pointer in sorted array. Uuntil there is elements in first array. Or it possiple to shift elements from the answer array. In this case push into the asnwer (or modify), and shift from the sorted.

 
Ruby code:
```Ruby
# Leetcode: 56. Merge Intervals. 
# https://leetcode.com/problems/merge-intervals/
# = = = = = = =
# Accepted.
# Thanks God!
# = = = = = = =
# Runtime: 80 ms, faster than 49.06% of Ruby online submissions for Merge Intervals.
# Memory Usage: 210.6 MB, less than 64.15% of Ruby online submissions for Merge Intervals.
# @param {Integer[][]} intervals
# @return {Integer[][]}
def merge(intervals)
  inter = intervals.sort{|a,b|
    if a[0] != b[0]
      a[0] - b[0]
    else
      a[1] - b[1]
    end
  }
  x = inter.shift()
  ans = []
  ans.push(x)
  while ! inter.empty?
    x = inter.shift()
    if overlap(ans.last, x)
      min_start = ans.last[0]
      max_end = ans.last[1]
      min_start = x[0] if x[0] < min_start
      max_end = x[1] if x[1] > max_end
      ans.last[0] = min_start
      ans.last[1] = max_end
    else
      ans.push(x)
    end
  end
  ans
end

def overlap(a,b)
  # Starts before end.
  # Ends after start.
  a[0] <= b[1] && a[1] >= b[0]
end
```
